{"version":3,"file":"index.js","sources":["../../../../../shared/Swiper/index.tsx"],"sourcesContent":["// TODO: подумать над блокировкой вертикального скролла страницы (body-scroll-lock? native events + preventDefault?)\nimport React, { useMemo, useState } from 'react';\n\ninterface SwiperProps {\n  /** Тег swipeable контейнера */\n  tag: keyof JSX.IntrinsicElements;\n\n  /** Callback по свайпу вверх */\n  onSwipedUp?: () => void;\n\n  /** Callback по свайпу вниз */\n  onSwipedDown?: () => void;\n\n  /** Callback по свайпу влево */\n  onSwipedLeft?: () => void;\n\n  /** Callback по свайпу вправо */\n  onSwipedRight?: () => void;\n\n  /** Порог срабатывания callback'ов (px) */\n  threshold: number;\n\n  /** Флаг растягивания контейнера по размеру родителя */\n  stretch?: boolean;\n}\n\nconst getCurrentCoordinates = (event: React.MouseEvent | React.TouchEvent): { currentX: number; currentY: number } => {\n  const { touches } = event as React.TouchEvent;\n  const touch = touches?.[0];\n  const { clientX, clientY } = touch || event as React.MouseEvent;\n\n  return {\n    currentX: parseFloat(clientX.toFixed(2)),\n    currentY: parseFloat(clientY.toFixed(2))\n  };\n};\n\nconst Swiper: React.FC<SwiperProps> = ({\n  tag: Wrapper,\n  threshold,\n  onSwipedUp,\n  onSwipedDown,\n  onSwipedLeft,\n  onSwipedRight,\n  stretch,\n  children\n}) => {\n  const [x, setX] = useState(0);\n  const [y, setY] = useState(0);\n  const [isMoving, setIsMoving] = useState(false);\n  const [swipePerformed, setSwipePerformed] = useState(false);\n\n  const beforeHandle = (event: React.MouseEvent | React.TouchEvent): React.MouseEvent | React.TouchEvent => {\n    event.stopPropagation();\n\n    return event;\n  };\n\n  const moveStart = (event: React.MouseEvent | React.TouchEvent): void => {\n    const { currentX, currentY } = getCurrentCoordinates(event);\n\n    setX(currentX);\n    setY(currentY);\n    setIsMoving(true);\n    setSwipePerformed(false);\n  };\n\n  const handleHorizontalSwipe = (dx: number): void => {\n    if (dx > threshold && onSwipedRight) {\n      onSwipedRight();\n    } else if (dx < -threshold && onSwipedLeft) {\n      onSwipedLeft();\n    }\n\n    setSwipePerformed(true);\n  };\n\n  const handleVerticalSwipe = (dy: number): void => {\n    if (dy > threshold && onSwipedDown) {\n      onSwipedDown();\n    } else if (dy < -threshold && onSwipedUp) {\n      onSwipedUp();\n    }\n\n    setSwipePerformed(true);\n  };\n\n  const move = (event: React.MouseEvent | React.TouchEvent): void => {\n    if (!isMoving) {\n      return;\n    }\n\n    const { currentX, currentY } = getCurrentCoordinates(event);\n    const dx: number = parseFloat((currentX - x).toFixed(2));\n    const dy: number = parseFloat((currentY - y).toFixed(2));\n\n    if (!swipePerformed) {\n      if (Math.abs(dx) >= threshold) {\n        handleHorizontalSwipe(dx);\n\n        return;\n      }\n\n      if (Math.abs(dy) >= threshold) {\n        handleVerticalSwipe(dy);\n      }\n    }\n  };\n\n  const moveEnd = (): void => {\n    setX(0);\n    setY(0);\n    setIsMoving(false);\n    setSwipePerformed(false);\n  };\n\n  const onStart = (event: React.MouseEvent | React.TouchEvent): void => {\n    const evt: React.MouseEvent | React.TouchEvent = beforeHandle(event);\n    moveStart(evt);\n  };\n\n  const onMove = (event: React.MouseEvent | React.TouchEvent): void => {\n    const evt: React.MouseEvent | React.TouchEvent = beforeHandle(event);\n    move(evt);\n  };\n\n  const onEnd = (event: React.MouseEvent | React.TouchEvent): void => {\n    beforeHandle(event);\n    moveEnd();\n  };\n\n  const swiperStyles = useMemo(() => (stretch ? { width: '100%', height: '100%' } : undefined), [stretch]);\n\n  return (\n    <Wrapper\n      onTouchStart={ onStart }\n      onTouchMove={ onMove }\n      onTouchEnd={ onEnd }\n      onTouchCancel={ onEnd }\n      onMouseLeave={ onEnd }\n      onMouseDown={ onStart }\n      onMouseMove={ onMove }\n      onMouseUp={ onEnd }\n      style={ swiperStyles }\n    >\n      { children }\n    </Wrapper>\n  );\n};\n\nexport default Swiper;\n"],"names":["getCurrentCoordinates","event","touches","_a","clientX","clientY","currentX","parseFloat","toFixed","currentY","Swiper","Wrapper","threshold","onSwipedUp","onSwipedDown","onSwipedLeft","onSwipedRight","stretch","children","_b","useState","x","setX","_c","y","setY","_d","isMoving","setIsMoving","_e","swipePerformed","setSwipePerformed","beforeHandle","stopPropagation","move","dx","dy","Math","abs","handleHorizontalSwipe","handleVerticalSwipe","onStart","moveStart","onMove","evt","onEnd","swiperStyles","useMemo","width","height","undefined","React","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","onMouseLeave","onMouseDown","onMouseMove","onMouseUp","style"],"mappings":"iDA0BA,IAAMA,EAAwB,SAACC,GACrB,IAAAC,EAAYD,UAEdE,GADQD,eAAAA,EAAU,KACcD,EAA9BG,YAASC,YAEjB,MAAO,CACLC,SAAUC,WAAWH,EAAQI,QAAQ,IACrCC,SAAUF,WAAWF,EAAQG,QAAQ,IAEzC,EAEME,EAAgC,SAACP,OAChCQ,QACLC,cACAC,eACAC,iBACAC,iBACAC,kBACAC,YACAC,aAEMC,EAAYC,EAAS,GAApBC,OAAGC,OACJC,EAAYH,EAAS,GAApBI,OAAGC,OACJC,EAA0BN,GAAS,GAAlCO,OAAUC,OACXC,EAAsCT,GAAS,GAA9CU,OAAgBC,OAEjBC,EAAe,SAAC/B,GAGpB,OAFAA,EAAMgC,kBAEChC,GAgCHiC,EAAO,SAACjC,GACZ,GAAK0B,EAAL,CAIM,IAAAxB,EAAyBH,EAAsBC,GAA7CK,aAAUG,aACZ0B,EAAa5B,YAAYD,EAAWe,GAAGb,QAAQ,IAC/C4B,EAAa7B,YAAYE,EAAWe,GAAGhB,QAAQ,IAErD,IAAKsB,EAAgB,CACnB,GAAIO,KAAKC,IAAIH,IAAOvB,EAGlB,YAjCwB,SAACuB,GACzBA,EAAKvB,GAAaI,EACpBA,IACSmB,GAAMvB,GAAaG,GAC5BA,IAGFgB,GAAkB,GAwBdQ,CAAsBJ,GAKpBE,KAAKC,IAAIF,IAAOxB,GA1BI,SAACwB,GACvBA,EAAKxB,GAAaE,EACpBA,IACSsB,GAAMxB,GAAaC,GAC5BA,IAGFkB,GAAkB,GAoBdS,CAAoBJ,MAYpBK,EAAU,SAACxC,IA1DC,SAACA,GACX,IAAAE,EAAyBH,EAAsBC,GAA7CK,aAAUG,aAElBa,EAAKhB,GACLmB,EAAKhB,GACLmB,GAAY,GACZG,GAAkB,GAsDlBW,CADiDV,EAAa/B,KAI1D0C,EAAS,SAAC1C,GACd,IAAM2C,EAA2CZ,EAAa/B,GAC9DiC,EAAKU,IAGDC,EAAQ,SAAC5C,GACb+B,EAAa/B,GAjBbqB,EAAK,GACLG,EAAK,GACLG,GAAY,GACZG,GAAkB,IAkBde,EAAeC,GAAQ,WAAM,OAAC9B,EAAU,CAAE+B,MAAO,OAAQC,OAAQ,aAAWC,IAAY,CAACjC,IAE/F,OACEkC,gBAACxC,GACCyC,aAAeX,EACfY,YAAcV,EACdW,WAAaT,EACbU,cAAgBV,EAChBW,aAAeX,EACfY,YAAchB,EACdiB,YAAcf,EACdgB,UAAYd,EACZe,MAAQd,GAEN5B,EAGR"}