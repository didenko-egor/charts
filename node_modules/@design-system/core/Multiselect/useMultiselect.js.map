{"version":3,"file":"useMultiselect.js","sources":["../../src/Multiselect/useMultiselect.tsx"],"sourcesContent":["import React, { useCallback, useMemo } from 'react';\nimport { BaseSelectItem } from 'core/types/select';\nimport { SizeMark } from 'core/types/mark';\n\nimport { Mark } from '../Mark';\n\ninterface UseMultiselectProps {\n  /** Элементы из которых можно выбирать  */\n  items: BaseSelectItem[];\n\n  /** ID выбранных элементов */\n  activeValue?: string[];\n\n  /** Размер меток */\n  markSize?: SizeMark;\n\n  /** Обработчик изменения выбранных элементов */\n  onChangeActiveValue?: (values: string[]) => void;\n}\n\ninterface UseMultiselectResult {\n  /** Строка с перечислением выбранных элементов */\n  activeLabels: string;\n\n  /** Обработчик изменения выбора элемента */\n  toggleActiveValue: (value: string) => void;\n\n  /** Обработчик нажатия на кнопки для удаления последнего элемента в списке */\n  handleDeleteLastItem: (event: React.KeyboardEvent) => void;\n\n  /** Получить метки выбранных элементов */\n  getMarks: () => JSX.Element[];\n}\n\n/** Логика работы множественного выбора */\nexport default function useMultiselect({\n  items,\n  activeValue,\n  markSize = 'default',\n  onChangeActiveValue\n}: UseMultiselectProps): UseMultiselectResult {\n  const toggleActiveValue = useCallback((value: string) => {\n    if (!onChangeActiveValue) {\n      return;\n    }\n\n    /** Это первый элемент, сразу добавить его в список */\n    if (!activeValue) {\n      onChangeActiveValue([value]);\n\n      return;\n    }\n\n    let isToBePushed = true;\n\n    /** Получить элементы, с которых не снят выбор */\n    const result = activeValue.filter(active => {\n      /** Если выбирается ранее выбранный элемент, с него нужно снять выделение */\n      const isInactive = active !== value;\n\n      /** Если  элемент ранее не был выбран - добавить его в выбранные */\n      isToBePushed = isToBePushed && isInactive;\n\n      return isInactive;\n    });\n\n    if (isToBePushed) {\n      result.push(value);\n    }\n\n    onChangeActiveValue(result);\n  }, [activeValue, onChangeActiveValue]);\n\n  /** Map для более быстрого поиска по элементам в списке */\n  const itemsMap = useMemo(() => items.reduce((acc, item) => {\n    acc.set(item.value, item);\n\n    return acc;\n  }, new Map()), [items]);\n\n  /** Преобразовать ID выбранных элементов в объекты элементов */\n  const activeItems = useMemo(\n    () => {\n      if (!activeValue) return [];\n\n      return activeValue.map(value => itemsMap.get(value));\n    },\n    [activeValue, itemsMap]\n  );\n\n  /** Текст, который отображается, когда компонент закрыт.\n   * Перечисляет лейблы выбранных элементов\n   */\n  const activeLabels = useMemo(\n    () => activeItems.map(item => item.label).join(', '),\n    [activeItems]\n  );\n\n  const getMarks = useCallback(\n    () => activeItems.map(item => (\n      <Mark\n        key={ item.value }\n        text={ item.label }\n        size={ markSize }\n        onClose={ (): void => toggleActiveValue(item.value) }\n      />\n    )),\n    [activeItems, markSize, toggleActiveValue]\n  );\n\n  /** Обработчик удаление последнего выбранного элемента */\n  const handleDeleteLastItem = useCallback((event: React.KeyboardEvent) => {\n    if (!onChangeActiveValue || !activeValue || activeValue.length <= 0) return;\n\n    if (event.key !== 'Backspace') return;\n\n    /** Если при поиске находимся в input, удаляем метки, только после всего текста */\n    const target = event.target as HTMLInputElement;\n    if (target.tagName === 'INPUT' && target.value.length > 0) {\n      return;\n    }\n\n    /** Удалить последний выбранный элемент */\n    const newActiveValue = activeValue.slice(0, activeValue.length - 1);\n    onChangeActiveValue(newActiveValue);\n  }, [activeValue, onChangeActiveValue]);\n\n  return {\n    activeLabels,\n    toggleActiveValue,\n    getMarks,\n    handleDeleteLastItem\n  };\n}\n"],"names":["useMultiselect","_a","items","activeValue","_b","markSize","onChangeActiveValue","toggleActiveValue","useCallback","value","isToBePushed","result","filter","active","isInactive","push","itemsMap","useMemo","reduce","acc","item","set","Map","activeItems","map","get","activeLabels","label","join","getMarks","React","Mark","key","text","size","onClose","handleDeleteLastItem","event","length","target","tagName","newActiveValue","slice"],"mappings":"qGAmCwBA,EAAeC,OACrCC,UACAC,gBACAC,aAAAC,aAAW,YACXC,wBAEMC,EAAoBC,GAAY,SAACC,GACrC,GAAKH,EAKL,GAAKH,EAAL,CAMA,IAAIO,GAAe,EAGbC,EAASR,EAAYS,QAAO,SAAAC,GAEhC,IAAMC,EAAaD,IAAWJ,EAK9B,OAFAC,EAAeA,GAAgBI,EAExBA,KAGLJ,GACFC,EAAOI,KAAKN,GAGdH,EAAoBK,QAtBlBL,EAAoB,CAACG,MAuBtB,CAACN,EAAaG,IAGXU,EAAWC,GAAQ,WAAM,OAAAf,EAAMgB,QAAO,SAACC,EAAKC,GAGhD,OAFAD,EAAIE,IAAID,EAAKX,MAAOW,GAEbD,IACN,IAAIG,OAAQ,CAACpB,IAGVqB,EAAcN,GAClB,WACE,OAAKd,EAEEA,EAAYqB,KAAI,SAAAf,GAAS,OAAAO,EAASS,IAAIhB,MAFpB,KAI3B,CAACN,EAAaa,IAMVU,EAAeT,GACnB,WAAM,OAAAM,EAAYC,KAAI,SAAAJ,GAAQ,OAAAA,EAAKO,SAAOC,KAAK,QAC/C,CAACL,IAGGM,EAAWrB,GACf,WAAM,OAAAe,EAAYC,KAAI,SAAAJ,GAAQ,OAC5BU,gBAACC,GACCC,IAAMZ,EAAKX,MACXwB,KAAOb,EAAKO,MACZO,KAAO7B,EACP8B,QAAU,WAAY,OAAA5B,EAAkBa,EAAKX,eAGjD,CAACc,EAAalB,EAAUE,IAIpB6B,EAAuB5B,GAAY,SAAC6B,GACxC,GAAK/B,GAAwBH,KAAeA,EAAYmC,QAAU,IAEhD,cAAdD,EAAML,IAAV,CAGA,IAAMO,EAASF,EAAME,OACrB,KAAuB,UAAnBA,EAAOC,SAAuBD,EAAO9B,MAAM6B,OAAS,GAAxD,CAKA,IAAMG,EAAiBtC,EAAYuC,MAAM,EAAGvC,EAAYmC,OAAS,GACjEhC,EAAoBmC,OACnB,CAACtC,EAAaG,IAEjB,MAAO,CACLoB,eACAnB,oBACAsB,WACAO,uBAEJ"}