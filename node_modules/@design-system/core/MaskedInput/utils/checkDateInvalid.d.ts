import { DateFormat } from "../types";
type DatePeriod = 'day' | 'month' | 'year';
type DatePeriodIndexes = {
    [key in DatePeriod]?: number;
};
/** Парсит переданный формат даты, определяя в нём индексы дня, месяца и года (если есть)
 * @param {DateFormat} format формат для парсинга
 * @returns {DatePeriodIndexes} объект, в котором указаны индексы позиций,
 * на которых ожидаются для ввода значения дня, месяца и года (если они есть в переданном формате)
 */
declare const parseDateFormat: (format: DateFormat) => DatePeriodIndexes;
/** Проверяет значение дня месяца
 * @param {number} month
 * @param {number} day
 * @param {boolean | undefined} isLeapYear признак високосного года
 * @returns {boolean} результат проверки. В месяце не может более 31 дня,
 * а в феврале - не более 29 для високосного и 28 для невисокосного года
 */
declare const checkMonthDayInvalid: (month: number, day: number, isLeapYear?: boolean | undefined) => boolean;
/** Приводит двузначное целое число года к 4х значному формату. Прочие - остаются как есть.
 * @param {number} year год
 * @returns 4х значное число. Если число более 100, оно возвращается как есть.
 * Числа от 0 до текущего года приводятся к 21 веку, а с текущего года по 99 - 20-му
 * */
declare const getFullYear: (year: number) => number;
/**
 * Функция проверки на НЕвалидность даты в соответствии с переданным форматом
 * @param {string} value дата
 * @param {DateFormat} format формат, которому должна соответствовать дата
 * @returns {boolean} возвращает "true" если введенное значение не прошло валидацию
 */
declare const checkDateInvalid: (value: string, format: DateFormat) => boolean;
export { parseDateFormat, checkMonthDayInvalid, getFullYear, checkDateInvalid };
