{"version":3,"file":"checkTimeInvalid.js","sources":["../../../src/MaskedInput/utils/checkTimeInvalid.ts"],"sourcesContent":["import { TimeFormat } from '../types';\n\ntype TimePeriod = 'hours' | 'minutes' | 'seconds';\n\ntype TimePeriodIndexes = {\n  [key in TimePeriod]?: number\n};\n\n// Регэксп для проверки количества часов. Валидные значения (0-23)\nconst hoursRegexp = /^([0-1]?\\d|[2][0-3])$/g;\n// Регэксп для проверки количества минут. Валидные значения (0-59)\nconst minutesSecondsRegexp = /^([0-5])?\\d$/g;\n\n/** Парсит переданный формат времени, определяя в нём индексы часов, минут и секунд (если есть)\n * @param {DateFormat} format формат для парсинга\n * @returns {TimePeriodIndexes} объект, в котором указаны индексы позиций,\n * на которых ожидаются для ввода значения часов, минут и секунд (если они есть в переданном формате)\n */\nexport const parseTimeFormat = (format: TimeFormat): TimePeriodIndexes => {\n  const datePeriodIndexes: TimePeriodIndexes = {\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined\n  };\n\n  format.match(/[A-Z]?[a-z]+/g)?.forEach((period: string, index: number) => {\n    datePeriodIndexes[period.toLocaleLowerCase() as TimePeriod] = index;\n  });\n\n  return datePeriodIndexes;\n};\n\n/**\n * Функция проверки на НЕвалидность времени в соответствии с переданным форматом\n * @param {string} value время\n * @param {DateFormat} format формат, которому должно соответствовать время\n * @returns {boolean} возвращает \"true\" если введенное значение не прошло валидацию\n */\nexport const checkTimeInvalid = (value: string, format: TimeFormat): boolean => {\n  const timePeriodIndexes = parseTimeFormat(format);\n  const splittedValue = value.split(/[^\\d]/g);\n\n  if (typeof timePeriodIndexes.hours !== 'undefined') {\n    const hours = splittedValue[timePeriodIndexes.hours];\n\n    if (hours && hours.search(hoursRegexp) === -1) {\n      return true;\n    }\n  }\n\n  if (typeof timePeriodIndexes.minutes !== 'undefined') {\n    const minutes = splittedValue[timePeriodIndexes.minutes];\n\n    if (minutes && minutes.search(minutesSecondsRegexp) === -1) {\n      return true;\n    }\n  }\n\n  if (typeof timePeriodIndexes.seconds !== 'undefined') {\n    const seconds = splittedValue[timePeriodIndexes.seconds];\n\n    if (seconds && seconds.search(minutesSecondsRegexp) === -1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"names":["hoursRegexp","minutesSecondsRegexp","parseTimeFormat","format","datePeriodIndexes","hours","undefined","minutes","seconds","match","forEach","period","index","toLocaleLowerCase","checkTimeInvalid","value","timePeriodIndexes","splittedValue","split","search"],"mappings":"AASA,IAAMA,EAAc,yBAEdC,EAAuB,gBAOhBC,EAAkB,SAACC,SACxBC,EAAuC,CAC3CC,WAAOC,EACPC,aAASD,EACTE,aAASF,GAOX,iBAJAH,EAAOM,MAAM,iCAAkBC,SAAQ,SAACC,EAAgBC,GACtDR,EAAkBO,EAAOE,qBAAqCD,KAGzDR,CACT,EAQaU,EAAmB,SAACC,EAAeZ,GAC9C,IAAMa,EAAoBd,EAAgBC,GACpCc,EAAgBF,EAAMG,MAAM,UAElC,QAAuC,IAA5BF,EAAkBX,MAAuB,CAClD,IAAMA,EAAQY,EAAcD,EAAkBX,OAE9C,GAAIA,IAAwC,IAA/BA,EAAMc,OAAOnB,GACxB,OAAO,EAIX,QAAyC,IAA9BgB,EAAkBT,QAAyB,CACpD,IAAMA,EAAUU,EAAcD,EAAkBT,SAEhD,GAAIA,IAAqD,IAA1CA,EAAQY,OAAOlB,GAC5B,OAAO,EAIX,QAAyC,IAA9Be,EAAkBR,QAAyB,CACpD,IAAMA,EAAUS,EAAcD,EAAkBR,SAEhD,GAAIA,IAAqD,IAA1CA,EAAQW,OAAOlB,GAC5B,OAAO,EAIX,OAAO,CACT"}