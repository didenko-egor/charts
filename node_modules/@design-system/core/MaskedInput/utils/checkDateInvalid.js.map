{"version":3,"file":"checkDateInvalid.js","sources":["../../../src/MaskedInput/utils/checkDateInvalid.ts"],"sourcesContent":["import type { DateFormat } from '../types';\n\ntype DatePeriod = 'day' | 'month' | 'year';\n\ntype DatePeriodIndexes = {\n  [key in DatePeriod]?: number\n};\n\n/** Календарные номера месяцев, в которых 30 дней */\nconst monthWith30Days = [2, 4, 6, 9, 11];\n\n/** Список високосных годов (неполный) */\nconst leapYears = [\n  1904, 1908, 1912, 1916, 1920, 1924,\n  1928, 1932, 1936, 1940, 1944, 1948,\n  1952, 1956, 1960, 1964, 1968, 1972,\n  1976, 1980, 1984, 1988, 1992, 1996,\n  2000, 2004, 2008, 2012, 2016, 2020,\n  2024, 2028, 2032, 2036, 2040, 2044,\n  2048, 2052, 2056, 2060, 2064, 2068\n];\n\n// Регэксп для проверки года. Валидным будет считаться год 2х (00-99) или 4х символьный (1900-2069)\nconst yearRegexp = /^(20[0-6]\\d)|^(19\\d\\d)|^(\\d\\d)$/g;\n\n/** Парсит переданный формат даты, определяя в нём индексы дня, месяца и года (если есть)\n * @param {DateFormat} format формат для парсинга\n * @returns {DatePeriodIndexes} объект, в котором указаны индексы позиций,\n * на которых ожидаются для ввода значения дня, месяца и года (если они есть в переданном формате)\n */\nexport const parseDateFormat = (format: DateFormat): DatePeriodIndexes => {\n  const datePeriodIndexes: DatePeriodIndexes = {\n    day: undefined,\n    month: undefined,\n    year: undefined\n  };\n\n  format.match(/[A-Z]?[a-z]+/g)?.forEach((period: string, index: number) => {\n    datePeriodIndexes[period.toLocaleLowerCase() as DatePeriod] = index;\n  });\n\n  return datePeriodIndexes;\n};\n\n/** Проверяет значение дня месяца\n * @param {number} month\n * @param {number} day\n * @param {boolean | undefined} isLeapYear признак високосного года\n * @returns {boolean} результат проверки. В месяце не может более 31 дня,\n * а в феврале - не более 29 для високосного и 28 для невисокосного года\n */\nexport const checkMonthDayInvalid = (month: number, day: number, isLeapYear?: boolean): boolean => {\n  if (day < 1 || day > 31) return true;\n\n  if (month === 2) {\n    return isLeapYear ?? true ? day > 29 : day > 28;\n  }\n\n  return monthWith30Days.includes(month) && day > 30;\n};\n\n/** Приводит двузначное целое число года к 4х значному формату. Прочие - остаются как есть.\n * @param {number} year год\n * @returns 4х значное число. Если число более 100, оно возвращается как есть.\n * Числа от 0 до текущего года приводятся к 21 веку, а с текущего года по 99 - 20-му\n * */\nexport const getFullYear = (year: number): number => {\n  let fullYear = year;\n\n  if (fullYear < 100) {\n    fullYear = year <= new Date().getFullYear() % 2000 ? 2000 + year : 1900 + year;\n  }\n\n  return fullYear;\n};\n\n/**\n * Функция проверки на НЕвалидность даты в соответствии с переданным форматом\n * @param {string} value дата\n * @param {DateFormat} format формат, которому должна соответствовать дата\n * @returns {boolean} возвращает \"true\" если введенное значение не прошло валидацию\n */\nexport const checkDateInvalid = (value: string, format: DateFormat): boolean => {\n  let isLeapYear;// признак високосного года\n\n  const datePeriodIndexes = parseDateFormat(format);\n  const splittedValue = value.split(/[^\\d]/g).map(strNumber => Number(strNumber));\n\n  if (typeof datePeriodIndexes.year !== 'undefined') {\n    const year = splittedValue[datePeriodIndexes.year];\n\n    if (year) {\n      const fullYear = getFullYear(year);\n\n      isLeapYear = leapYears.includes(fullYear);\n\n      if (year.toString().search(yearRegexp) === -1) {\n        return true;\n      }\n    }\n  }\n\n  if (typeof datePeriodIndexes.month !== 'undefined') {\n    const month = splittedValue[datePeriodIndexes.month];\n\n    if (month > 12 || month < 1) {\n      return true;\n    }\n\n    if (typeof datePeriodIndexes.day !== 'undefined') {\n      const day = splittedValue[datePeriodIndexes.day];\n\n      return checkMonthDayInvalid(month, day, isLeapYear);\n    }\n  }\n\n  return false;\n};\n"],"names":["monthWith30Days","leapYears","yearRegexp","parseDateFormat","format","datePeriodIndexes","day","undefined","month","year","match","forEach","period","index","toLocaleLowerCase","checkMonthDayInvalid","isLeapYear","includes","getFullYear","fullYear","Date","checkDateInvalid","value","splittedValue","split","map","strNumber","Number","toString","search"],"mappings":"AASA,IAAMA,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,IAG/BC,EAAY,CAChB,KAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,KAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,KAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,KAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,IAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,KAAM,KAAM,KAAM,KAAM,KAAM,KAC9B,KAAM,KAAM,KAAM,KAAM,KAAM,MAI1BC,EAAa,mCAONC,EAAkB,SAACC,SACxBC,EAAuC,CAC3CC,SAAKC,EACLC,WAAOD,EACPE,UAAMF,GAOR,iBAJAH,EAAOM,MAAM,iCAAkBC,SAAQ,SAACC,EAAgBC,GACtDR,EAAkBO,EAAOE,qBAAqCD,KAGzDR,CACT,EASaU,EAAuB,SAACP,EAAeF,EAAaU,GAC/D,OAAIV,EAAM,GAAKA,EAAM,KAEP,IAAVE,EACKQ,SAAAA,EAAqBV,EAAM,GAAKA,EAAM,GAGxCN,EAAgBiB,SAAST,IAAUF,EAAM,GAClD,EAOaY,EAAc,SAACT,GAC1B,IAAIU,EAAWV,EAMf,OAJIU,EAAW,MACbA,EAAWV,IAAQ,IAAIW,MAAOF,cAAgB,IAAO,IAAOT,EAAO,KAAOA,GAGrEU,CACT,EAQaE,EAAmB,SAACC,EAAelB,GAC9C,IAAIY,EAEEX,EAAoBF,EAAgBC,GACpCmB,EAAgBD,EAAME,MAAM,UAAUC,KAAI,SAAAC,GAAa,OAAAC,OAAOD,MAEpE,QAAsC,IAA3BrB,EAAkBI,KAAsB,CACjD,IAAMA,EAAOc,EAAclB,EAAkBI,MAE7C,GAAIA,EAAM,CACR,IAAMU,EAAWD,EAAYT,GAI7B,GAFAO,EAAaf,EAAUgB,SAASE,IAEY,IAAxCV,EAAKmB,WAAWC,OAAO3B,GACzB,OAAO,GAKb,QAAuC,IAA5BG,EAAkBG,MAAuB,CAClD,IAAMA,EAAQe,EAAclB,EAAkBG,OAE9C,GAAIA,EAAQ,IAAMA,EAAQ,EACxB,OAAO,EAGT,QAAqC,IAA1BH,EAAkBC,IAAqB,CAChD,IAAMA,EAAMiB,EAAclB,EAAkBC,KAE5C,OAAOS,EAAqBP,EAAOF,EAAKU,IAI5C,OAAO,CACT"}