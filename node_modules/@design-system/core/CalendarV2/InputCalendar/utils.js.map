{"version":3,"file":"utils.js","sources":["../../../src/CalendarV2/InputCalendar/utils.ts"],"sourcesContent":["import { MouseEvent } from 'react';\nimport { format, parse } from 'date-fns';\nimport { CalendarInitialState, CalendarPage, SelectedDate } from 'core/shared/PageCalendar/types';\n\n/** Регулярка, проверяющая введена ли валидная дата или инпут пуст */\n// eslint-disable-next-line max-len\nexport const DATE_REG_EXP = /^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^\\s*$/;\n\n/** Возвращает валидный для date-fns паттерн на основании переданной строки с датой */\nexport function getPattern(dateStr: string): string {\n  if (dateStr && dateStr.split('.').length >= 3) {\n    const [day, month, year] = dateStr.split('.');\n    const patternValues = ['d'.repeat(day.length), 'L'.repeat(month.length), 'y'.repeat(year.length)];\n\n    return patternValues.join('.');\n  }\n\n  return 'dd.LL.yyyy';\n}\n\n/** Преобразовать строку в дату */\nexport function formatStringToDate(value?: string): Date | undefined {\n  if (!value) return undefined;\n\n  const isValid = DATE_REG_EXP.test(value);\n\n  if (!isValid) return undefined;\n\n  return parse(value, getPattern(value), new Date());\n}\n\n/** Преобразовать дату в строку */\nexport function formatDateToString(value?: Date, pattern = ''): string {\n  // if (value && prevInput) {\n  //   const prevDate = formatStringToDate(prevInput);\n  //   if (prevDate && dayEqual(value, prevDate)) {\n  //     return prevInput;\n  //   }\n  // }\n\n  return value ? format(value, getPattern(pattern)) : '';\n}\n\n/** Заблокировать всплытие события */\nexport function stopPropagation(event: MouseEvent): void {\n  event.stopPropagation();\n}\n\nexport function getSelectedDateFromString(value?: string): SelectedDate | undefined {\n  const v = formatStringToDate(value);\n\n  return v ? { from: v } : undefined;\n}\n\n/** Получить состояние календаря */\nexport function getCalendarState(\n  value?: Date | string,\n  defaultValue?: Date,\n  initialPage?: CalendarPage\n): CalendarInitialState | undefined {\n  const formattedValue = typeof value === 'string' ? formatStringToDate(value) : value;\n  const v = defaultValue ?? formattedValue ?? new Date();\n\n  return (v ? { date: v, page: initialPage ?? CalendarPage.Days } : undefined);\n}\n\n/** Проверить, что дата вписывается в min-max диапазон */\nexport function validateMinMax(date?: Date, minDate?: Date, maxDate?: Date): boolean {\n  if (!date) return true;\n\n  if (minDate && date < minDate) {\n    return false;\n  }\n\n  if (maxDate && date > maxDate) {\n    return false;\n  }\n\n  return true;\n}\n\n/** Валидация строки с датой с учётом min-max диапазона */\nexport function validateDateInput(inputValue: string, minDate?: Date, maxDate?: Date): boolean {\n  const isValid = DATE_REG_EXP.test(inputValue);\n\n  if (!isValid) return false;\n\n  // Проверить, что ввод завершён\n  if (inputValue.length !== 8 && inputValue.length !== 10) {\n    return true;\n  }\n\n  // Проверить Min/max\n  const date = parse(inputValue, getPattern(inputValue), new Date());\n\n  return validateMinMax(date, minDate, maxDate);\n}\n\n/**\n * Определяет, пора ли отобразить, что в поле ввода есть ошибка, или ещё нет\n * @param value Текущее значение\n * @param isValueValid Текущее значение валидно или нет с учетом Min Max?\n * @returns Считать валидным текущее значение или нет?\n */\nexport function checkCurrentInputValid(\n  value: string,\n  isValueValid: boolean\n): boolean {\n  if (value.length >= 8) {\n    // Если ввели более 8 символов - можно проводить отображение ошибки\n    if (value.length === 9) {\n      // Если ввели 9 символов, и до этого уже была ошибка, значит она останется и далее - отобразить это\n      const prev = value.slice(0, value.length - 1);\n\n      return DATE_REG_EXP.test(prev);\n    }\n\n    return isValueValid;\n  }\n\n  /** Если длина менее 8 символов - мы не можем сказать точно валидно или нет */\n  return true;\n}\n\n/** Внешний формат */\nexport interface DateFormat {\n  /** Ввод пустой */\n  isEmpty: boolean;\n\n  /** Дата */\n  value?: Date;\n}\n\n/** Преобразовать во внешний формат */\nexport function formatToDate(\n  value?: string,\n  minDate?: Date,\n  maxDate?: Date\n): DateFormat {\n  if (!value) return { isEmpty: true };\n\n  const isValid = validateDateInput(value, minDate, maxDate);\n  if (!isValid) return { isEmpty: false };\n\n  const date = parse(value, getPattern(value), new Date());\n\n  return { value: date, isEmpty: false };\n}\n"],"names":["DATE_REG_EXP","getPattern","dateStr","split","length","_a","day","month","year","repeat","join","formatStringToDate","value","test","parse","Date","formatDateToString","pattern","format","stopPropagation","event","getSelectedDateFromString","v","from","undefined","getCalendarState","defaultValue","initialPage","formattedValue","date","page","CalendarPage","Days","validateMinMax","minDate","maxDate","validateDateInput","inputValue","checkCurrentInputValid","isValueValid","prev","slice","formatToDate","isEmpty"],"mappings":"iIAMaA,EAAe,sVAGZC,EAAWC,GACzB,GAAIA,GAAWA,EAAQC,MAAM,KAAKC,QAAU,EAAG,CACvC,IAAAC,EAAqBH,EAAQC,MAAM,KAAlCG,OAAKC,OAAOC,OAGnB,MAFsB,CAAC,IAAIC,OAAOH,EAAIF,QAAS,IAAIK,OAAOF,EAAMH,QAAS,IAAIK,OAAOD,EAAKJ,SAEpEM,KAAK,KAG5B,MAAO,YACT,UAGgBC,EAAmBC,GACjC,GAAKA,GAEWZ,EAAaa,KAAKD,GAIlC,OAAOE,EAAMF,EAAOX,EAAWW,GAAQ,IAAIG,KAC7C,UAGgBC,EAAmBJ,EAAcK,GAQ/C,oBAR+CA,MAQxCL,EAAQM,EAAON,EAAOX,EAAWgB,IAAY,EACtD,UAGgBE,EAAgBC,GAC9BA,EAAMD,iBACR,UAEgBE,EAA0BT,GACxC,IAAMU,EAAIX,EAAmBC,GAE7B,OAAOU,EAAI,CAAEC,KAAMD,QAAME,CAC3B,UAGgBC,EACdb,EACAc,EACAC,SAEMC,EAAkC,iBAAVhB,EAAqBD,EAAmBC,GAASA,EACzEU,YAAII,QAAAA,EAAgBE,iBAAkB,IAAIb,KAEhD,OAAQO,EAAI,CAAEO,KAAMP,EAAGQ,KAAMH,QAAAA,EAAeI,EAAaC,WAASR,CACpE,UAGgBS,EAAeJ,EAAaK,EAAgBC,GAC1D,OAAKN,KAEDK,GAAWL,EAAOK,MAIlBC,GAAWN,EAAOM,EAKxB,UAGgBC,EAAkBC,EAAoBH,EAAgBC,GAGpE,QAFgBnC,EAAaa,KAAKwB,KAKR,IAAtBA,EAAWjC,QAAsC,KAAtBiC,EAAWjC,QAOnC6B,EAFMnB,EAAMuB,EAAYpC,EAAWoC,GAAa,IAAItB,MAE/BmB,EAASC,GACvC,UAQgBG,EACd1B,EACA2B,GAEA,GAAI3B,EAAMR,QAAU,EAAG,CAErB,GAAqB,IAAjBQ,EAAMR,OAAc,CAEtB,IAAMoC,EAAO5B,EAAM6B,MAAM,EAAG7B,EAAMR,OAAS,GAE3C,OAAOJ,EAAaa,KAAK2B,GAG3B,OAAOD,EAIT,OAAO,CACT,UAYgBG,EACd9B,EACAsB,EACAC,GAEA,OAAKvB,EAEWwB,EAAkBxB,EAAOsB,EAASC,GAK3C,CAAEvB,MAFIE,EAAMF,EAAOX,EAAWW,GAAQ,IAAIG,MAE3B4B,SAAS,GAJV,CAAEA,SAAS,GAHb,CAAEA,SAAS,EAQhC"}